The literature review results revealed that (see section \ref{section:3.2}) there are different metrics and approaches for measuring the maintainability of software systems. On the other hand, considering the differences between Android applications and traditional software systems, it is obvious that a different maintainability assessment method is required for Android applications. When the problems encountered while developing Android applications, which were mentioned in the first chapter, are examined, it is seen that software characteristics such as software complexity, understandability/readability, modifiability come to the fore. Considering the relationship between maintainability and these characteristics, it was decided that the maintainability measurement to be carried out within the scope of this study should cover these characteristics. To evaluate these software characteristics, it is considered that complexity, cohesion and coupling concepts can be used because software complexity, modifiability, understandability/readability are affected by these concepts. These characteristics and concepts can be matched respectively with each other. As a result of this consideration, it was concluded that the measurements made based on these concepts could be efficient when measuring the maintainability of Android applications. Also, studies have shown that results retrieved from evaluating these concepts proved to define the level of maintainability \cite{33}. Therefore, the maintainability model of this study for quantitative evaluation was formed based on the concepts of complexity, cohesion and coupling and research was done on measuring these concepts effectively. As a result, five metrics were selected for this purpose. While selecting these metrics, priority has been given to metrics that can handle a software system as a whole in the areas of complexity, cohesion and coupling to make more efficient evaluations. These metrics and their intended use are listed below.
\begin{itemize}
    \item \textbf{Weighted Method Count (WMC):} This metric is used to measure object-oriented software systemsâ€™ complexity. WMC represents a class's cyclomatic complexity, also known as McCabe complexity \cite{35}. It, therefore, portrays the complexity of a class as a whole, and this measure can be used to indicate the maintainability level of the class. The number of methods and complexity can be used to divine maintaining effort. If the number of methods is high, that class is described as domain-specific and is less reusable. Also, such classes tend to be prone to change and defects.
    \item \textbf{Depth of Inheritance Tree (DIT):} This is another metric to measure software complexity. Inheritance increases software reusability; however, one side can create complexity by possibly violating encapsulation since the subclass needs to access the superclass. Furthermore, changes made during maintenance might increase the inheritance tree's depths by adding more children. Therefore, by assessing the inheritance tree available in the product, it is easy to predict how much effort needed to make it stable \cite{33}. It is harder to predict its behaviour if the tree depth is high, and this causes maintenance issues.
    \item \textbf{Number of Children (NOC):} NOC measures the number of descendants of a class, and it is used to measure the coupling level for the corresponding class. NOC also indicates the reusability level of a software system. It is assumed that the number of child classes and the maintainer's responsibility to maintain the children's behaviour are directly proportional. If the NOC level is high, it is harder to maintain and modify the class \cite{36}.
    \item \textbf{Coupling Between Object Classes (CBO):} This metric calculates the number of connections to other classes from a particular class, and it is used to measure coupling. A class is considered coupled if it depends on another class to get its work done \cite{34}. CBO metric is related to the reusability of the class. High coupling makes the code more difficult to maintain because changes in other classes can also affect that class. Therefore these classes are less reusable and less maintainable.
    \item \textbf{Lack of Cohesion of Methods (LCOM):} This metric is used to determine how class methods are related to each other, and it is applied to evaluate cohesion. Cohesion promotes the maintainability of the software systems. High cohesion for a class meant the class is understandable, maintainable and easy to modify \cite{33}.
\end{itemize}

CodeMR static code analysis tool has been chosen for this study for the purpose of quantitative evaluation\footnote{\url{https://www.codemr.co.uk}}. After this decision, communication was established with the CodeMR team, and a free license was obtained to be used in academic studies. It is a powerful software quality tool that is integrated with IDEs and supports multiple programming languages. The tool provides a set of metrics to measure coupling, complexity, cohesion and size. Besides, the tool provides a visualisation centric approach and generates detailed reports supported by different visualisation options. In this way, it facilitates understanding the results and allows recognition of the bigger picture of the projects from the complexity, coupling, and cohesion point of view. Detailed information on these metrics and assessment methods can be found on the tool's website. The tool can also be installed as a plugin in Android Studio and is very easy to use. Lastly, two studies conducted using this tool were examined to gather more information regarding the tool \cite{38,39}.The CodeMR static code analysis tool has been chosen for this study due to reasons mentioned above. To evaluate the impact of the methods and technologies mentioned in section \ref{section:2.3} on maintainability, the metrics were applied on two different code bases of the same project via CodeMR. Thus, the impact could be measured by comparing the results from both versions. Although the project's full content cannot be published due to the confidentiality reasons, more information regarding these codebases is shared in the next section.