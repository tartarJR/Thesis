%Considering the date this application started to be developed, the use of old-fashioned technologies is normal, but the lack of organization throughout the application is unusual. This unusual situation and the other features listed above seriously affect the understandability and maintainability of the application. On the other hand, this situation offers a great opportunity for this study to measure maintainability.

%It would not be wrong to say that this situation negatively affects the efficiency of quantitative evaluation and comparison because the features used when making the evaluation are less complicated than the other application features. Although using relatively less complicated features while making the assessment slightly reduces the results' effectiveness, it does not mean that these results are false or unrealistic. However, this situation is the study's biggest limitation and gives an idea of future study subjects. As a result, the metrics, whose details are shared in section 3.2, have been applied to these four different features of two code bases. 

%and these developers can be considered as mid or senior level Android developers and 40\% of the participants have five years or more experience.
%When the 164 participants of the survey are examined, it can be easily said that the survey level is sufficient in terms of participant diversity. This fact proves that the respondents are Android developers who have sufficient experience and are proficient at Android development. The responses to the rest of the survey questions can be interpreted based on that fact, which is believed to provide more accurate results.

%Considering that Kotlin is a programming language suggested by Google and Android and is more "programmer-friendly" than Java, it is not difficult to understand that the above table is not surprising. As of 2020, Google declared that more than 60\% of Android applications were developed with Kotlin. It can be said that the survey results largely overlap with this statement\footnote{\url{https://developer.android.com/kotlin}}. On the other hand, he fact that some users still use Java can be explained by the existence of Android applications developed with Java before Kotlin was declared as an official programming language for Android. As stated in section \ref{section:4.3}, Mooncascade's Android team develops Android applications using Kotlin programming language, unless otherwise requested by its customers. When the survey results presented in detail above and the company's choice are compared, it is seen that this choice coincides with the Android community’s current trends.

%Android Architecture Components framework provides some out of box solutions for MVVM. We see that Android developers highly adopt it as of the first quarter of 2021. In other words,  it can be said that as the developer experience increases, the tendency of the developers to choose more than one design pattern also increases. In this case, it can be said that experienced Android developers make the presentational design pattern selection by considering which design pattern will fit the project size and content, rather than what is more popular. As another proof of this situation, it can be shown that developers with 0-3 years of experience have answered this question by selecting the MVVM option. In other words, it is possible to talk about the tendency of Android developers at the beginning of their career to choose popular or "hype" technologies. proving that the knowledge of architecture and design pattern in software development correlates with experience. Lastly, concerning this question, it will be helpful to mention the participants’ tendency to choose design patterns such as MVC, MVP and MVI. Comparing the survey results with Figure 7, which is presented in section \ref{section:2.7} and cited from a study conducted a few years ago in Android architectures, we are faced with similar results despite minor differences. When we look at the comparison results, it is seen that MVVM and MVP were popular among the Android community a few years ago, but MVVM is more preferred today. As mentioned before, it can be said that since the MVVM design pattern started to be provided as an out of box solution by the Google Android team three years ago, this situation increased usage of the MVVM design pattern. In the survey, we also see that 18 of the participants declared that they used the MVC design pattern. Although the MVC design pattern is considered an outdated design pattern in the Android community, the existence of projects developed using this pattern, and considering the suitability of this pattern for small projects; it is understandable why the pattern is still in use. This fact is not surprising, given the MVI design pattern’s growing popularity during 2020 and 2021. It can be said that this population will increase even more in the upcoming period. As stated in section \ref{section:4.4.1}, Mooncascade's Android team prefers the MVVM presentational design pattern when developing Android applications. When the survey results (presented in detail above) and the company's choice are compared, it is seen that this choice coincides with the Android community’s current trends.

%Clean Architecture's details, pros and cons were previously shared, but it is widely used among developers, as seen from the survey results. As can be seen in Fig. \ref{fig:arch_patterns}, which is cited from a study on Android architecture carried out a few years ago. Considering the advantages of Clean Architecture, especially when developing large and complex Android applications, and the growing and complexity of Android applications, developers' choice of Clean Architecture makes much sense. Finally, it is possible to say that the Clean Architecture choice of the Mooncascade Android team coincides with the Android developer trends.

%The importance of the SOLID principles and their use requirements were discussed in detail in section \ref{section:SOLID}. Considering how important it is to comply with SOLID principles in software development processes, it can be said that this rate is below expected. It is not easy to understand why people who develop software professionally in the Android field or any other field do not want to follow SOLID principles or are not aware of these principles, especially if these people are experienced developers. As stated in chapter 4 before, Mooncascade's Android team actively applies SOLID principles in Android application development processes. This selection is compatible with general Android developer behaviour, as can be seen in the results above.


%The purpose, advantages and disadvantages of these principles are given in section 4 in detail. Although there are many advantages of Clean Code principles, discussions are still going on in Android and other software development communities about Uncle Bob and his principles. From this point of view, it can be understood that although most of them actively use these principles, some developers do not. This situation can be interpreted as applying advanced concepts such as Clean Code or SOLID while developing the software directly proportional to the experience. Mooncascade's Android team mainly applies Clean Code principles in Android application development processes. This selection is compatible with general Android developer behaviour when compared to the results above. Further information about how Mooncascade's Android team applies Clean Code principles can be found in section \ref{section:4.4.2}.

%Although the network library's use does not directly affect maintainability, this question was included in the questionnaire. It was also among the aims of this study to identify developer tendencies. Also, the use of some advanced networking libraries indirectly affects maintainability due to the out of box solutions they offer. For this reason, it was deemed appropriate to add this question to the survey. It would not be wrong to say that this library is mainly preferred due to its ease when integrating back-end systems running on REST architecture into Android applications. More detailed information and comments about these libraries can be found in \ref{section:4.5.2}. Mooncascade's Android team prefers Retrofit or Apollo libraries depending on the back-end system’s type to be used in the project. This preference is in line with the survey results. APOLLO ALTERNATIFI YOK

%This question was included in the survey, considering that many Android applications are based on asynchronous events and the impact of the tools used in managing these events on the application architecture and thus on maintainability.The use of more than one solution can be explained by applications that need to be maintained or preferring a solution based on the project needs. This situation can be explained by maintaining some previously coded applications using the AsyncTask and are still in use. The use of this solution is no longer recommended \footnote{\url{https://developer.android.com/reference/android/os/AsyncTask}}. Usage of Kotlin coroutines is increasing among Android developers, as it is easier to learn and use than the RxJava library and because it requires no external dependency. Although RxJava has a steep learning curve and faces the growing popularity of the Kotlin coroutines, it is still preferred by many Android developers for the advanced features it offers. However, there has been a severe increase of applications that have recently migrated their RxJava solutions to Kotlin coroutines\cite{42}. Although the Mooncascade Android prefers RxJava for now, it has been continuing its efforts to switch to Kotlin Coroutines solution. Details on how RxJava is by used are shared in section \ref{section:4.5.3}

%, which significantly impact software maintainability and software architecture when developing Android applications.Dagger 2 and Hilt are DI frameworks recommended by the Android team. However, it is predicted that Hilt's use will surpass Dagger 2 soon, primarily due to the ease of learning it brings and the decrease in boilerplate code  \footnote{\url{https://developer.android.com/training/dependency-injection/hilt-android}}. It can be said that the Koin is preferred among Android developers because of its ease of learning and its ability to get integrated into Android applications with much less boilerplate code when compared to Dagger 2. Also, it is essential to mention that Koin was developed by using Kotlin programming language. This situation is not surprising given that all of the participants, who were not aware of the concept of DI, had less than a year of experience. Because DI is an advanced software development concept, and its practical implementation is a technique that requires solid experience. It is not mandatory to use any DI framework when developing Android applications. Therefore, it can be mentioned that 17.5\% of the participants stated that they do not use any framework and apply their custom solutions. Mooncascade's Android team applies DI principles in their projects and makes these applications through the Dagger 2 framework. Details on how this framework is used are shared in section \ref{section:4.5.1}. The Team is also considering migrating to Hilt soon.

%The high rate of usage is understandable, considering the out of box solutions it offers in solving some of the difficulties encountered while developing Android applications (which were mentioned in the first section, e.g. activity/fragment life-cycle) and the other facilities it provides for Android developers. In addition to this situation, there are groups in the Android community that are distant from this framework because it causes some other difficulties while solving the previously mentioned problems. This claim is controversial, and its details are beyond the focus of this study. However, this may be the reason why some participants do not prefer using this framework.
%Mooncascade's Android team prefers to use the Android Architecture Components framework. Details on how this framework is used are shared in section \ref{section:4.5.4}.

%In this section, the interpretation of the metric values obtained from the analysis of cb-2 is presented.

%When the cb-1 values of the WMC metric used in complexity measurement are examined, it is seen that almost all entities of this codebase have low WMC levels. These results are at the expected level, as it is known that this codebase applies SOLID principles and some of the Clean Code principles well.
%The fact that most of the classes belonging to this codebase have low complexity character increases the maintainability of the codebase.

%When the DIT results are examined, it is seen that there are similar results to the cb-1 results. The base class structure in cb-1 is also found in cb-2. Many children classes inherit these base classes. Therefore, DIT values for some classes are middle-high level. This also indicates that inheritance is widely used throughout the project. Besides, when the content of the traits in inheritance was examined, it was observed that these features were functions with low complexity that frequently repeat between classes.From this point of view, it would not be wrong to say that there is no excessive use of inheritance for this codebase. The current inheritance practice is in a way that will increase reusability and enable maintainability.

%The NOC metric values of cb-2 are also similar to cb-1, and the reasons are similar to the reasons explained in the previous paragraph. It is seen that these values are complying with the DIT. In other words, the application of inheritance is not excessive and does not increase complexity. On the contrary, the use of this way of inheritance effectively utilizes reusability and thus increases maintainability. Besides, since the application is evaluated on only 4 features, the NOC values remain relatively low. These values can be higher, especially for the base classes, if a fully functional application is evaluated because more entities will inherit the base classes. However, this situation will not pose a problem in terms of complexity unless the DIT values are high; that is, the depth of inheritance is not high. The same is true for cb-1 as well.

%When the COB metric values of the classes are examined, it is seen that the application is in a good situation in terms of coupling. Since abstraction, dependency inversion and dependency injection principles are applied very tightly for this codebase, it is expected that the application will be smooth or with minimal problems in terms of coupling. Since low coupling provides great advantages in terms of reusability and ease of modification, it makes a great contribution to the maintainability of this codebase.

%The results for the LCOM metric of cb-2 display a rather interesting insight.
%As explained earlier, LCOM measures the relationship between methods of a class. The low relationship between the methods of the classes indicates that a class has multiple responsibilities, which reduces the understandability and ease of modification of the class. Therefore, low cohesion means low maintainability. Considering that the principles of SOLID and SoC are strictly applied while developing the cb-2, it should be considered normal that the classes are concise and have a single responsibility. Therefore the cohesion values are also high. 

%When the class-based metric values collected from assessing CB-2 are examined, it is shown that there are visible improvements in complexity, coupling and cohesion areas even for simple features such as splash, login, register. When Fig. \ref{fig:cb-2-donuts} and Fig. \ref{fig:cb-2-package} are examined, the second point that draws attention is that the dimensions are significantly reduced despite the increase in the number of classes and packages. Concise classes and the increase in the number of packages provides a more organized code base and a better-fragmented understanding of responsibility. This situation is also noticeable when the codebase is examined with the help of an IDE. The organization and understandability of cb-2 are at a high level. Besides, the levels of the classes in complexity, coupling are quite low, and cohesion is high. This situation can be shown as proof that the SOLID and SoC principles are applied correctly, and it can be said that there is a very positive effect on maintainability. On the other hand, when the project's bigger picture is examined (See Fig. 26), a few classes with moderate complexity and cohesion issues stand out. When these classes were investigated, it was seen that they were the classes called "View Model" in the MVVM design pattern. These classes are responsible for how and when the data will be displayed (in other words, display/view logic) in the MVVM design pattern. According to the principles of the MVVM design pattern, each view should have only one view model. In this case, the view models belonging to the views with more than one responsibility also have the logic of belonging to more than one responsibility. Therefore, these classes become more complex, and the cohesion of the classes decreases due to the methods and dependencies they have for different responsibilities. As long as the principles of the MVVM design pattern are followed, it would not be appropriate to divide these responsibilities between different classes. Nevertheless, the effects of the technology and principles used in the development of cb-2 on maintainability are obvious. It has been observed as a result of evaluating the cb-2 that these principles and technologies make a big difference even in the development of relatively simple features. While the results are not perfect, they are important as they offer a starting point for improving maintainability.

%Considering the general situation, it is seen that the participants stated that the current methods and technologies used have positive effects on maintainability, but they also touched on some negative points. 

%In this section, the interpretation of the metric values obtained from the analysis of cb-1 is given. When the class-based metric values obtained from evaluating cb-1 are examined, there are a few points that attract attention. 

%When the cb-1 values of the WMC metric used in complexity measurement are examined, it is seen that there are 2 problematic classes and some other classes have minor issues in terms of complexity. The classes A and B, which are mentioned in section \ref{section:4.3.4}, and have WMC values in the medium-high range, can be seen as problematic in terms of complexity. When evaluating the WMC metric values of the classes, it should be taken into account that classes with high complexity will have low maintainability characteristics.

%If the cb-1 results of the DIT metric related to complexity and inheritance are examined, generally minor problems are observed. The DIT values of some classes seem to be at the middle-high level. There are a few inherited base classes (e.g. BaseActivity, BaseFragment), and these classes contain frequently used simple functionality. These classes are the ones that usually have higher DIT values. It can be said that this situation does not pose a serious problem when the application is considered. Fig. \ref{fig:cb-1-donuts} shows how the children classes inheriting these base classes reflect on the DIT results. Even though inheritance has a positive effect on the reusability level of the software systems, excessive and deep use of inheritance is considered a threat to maintainability. However, in this case, the usage of inheritance does not seem deep and excessive.

%When looking at the NOC results, the classes seem to have low values. From this point of view, it can be said that the application of inheritance in the codebase is low. Although this situation can be interpreted as the coupling between the classes is low, when the evaluation results of the coupling metrics are examined, it is seen that this is not the case. However, low values of this metric also indicate low reusability of a software system. On the other hand, as stated in the previous paragraph, it is seen that some base classes and their inheritance in the codebase are reflected in NOC results as well. This situation can be seen when examining Fig. \ref{fig:cb-1-donuts}. Classes with low-medium NOC values correspond to these base classes.

%When the COB metric values of the classes are examined, it is seen that the application has some problems in terms of coupling. It can be said that classes with high CBO values tend to have low reusability and low maintainability character. When these two classes with high and very high COB values are examined, it is seen that these classes are A and B classes mentioned in the paragraph where the WMC metric results were interpreted. It is worth noting that these two classes are problematic classes for cb-1. Since the SOLID principles and dependency injection applications were not handled properly while developing the cb-1, it would not be wrong to say that these results are not surprising for the CBO values.

%When the results regarding the LCOM metric used in the measurement of cohesion level are examined, it is seen that the codebase has serious problems with the cohesion. This situation can be easily noticed when Fig. \ref{fig:cb-1-donuts} is examined. When Fig. \ref{fig:cb-1-package} is examined, the size of the classes and packages draw attention. This situation can be explained by the separation of responsibilities and the correct application of the "Single Responsibility" principle, the first of the SOLID principles. Classes that do not implement this principle correctly have different functionalities, independent of each other, which reduces cohesion.Classes with low cohesion are characterized as being closed to modification, and it is known that such classes tend to carry more than one responsibility in general. Classes of this character have low understandability, and this negatively affects maintainability. From this point of view, it would not be wrong to say that there are maintainability problems in a serious part of the application.

%Considering the metric results in general, it is seen that although the evaluation is made over features with relatively low complexity (splash, login, register, etc.), problems from CB-1 stand out. Apart from the comments based on the above metric values, when Fig. \ref{fig:cb-1-package} is examined, the first thing that catches the eye is a complex and unorganized packaging structure. Layer and feature-based packaging methods are internal in the project, which causes serious maintainability, understandability and organization problems. It is also noteworthy that some classes are large in size, which can be interpreted as lack of proper separation of concerns. The also codebase appears to have complexity, coupling and cohesion problems even with these relatively low complication features. In a few classes, these problems are at a very high level, and maintainability and organization problems at different levels in the project draw attention. Especially the coupling problem stands out for this code base. Considering that there are no healthy abstraction and dependency injection applications in the project, this result is not very surprising. Apart from this, the problematic classes that draw attention in the paragraphs where metrics are interpreted appear in figure 23 as well with their abnormal sizes and their issues in complexity, coupling and cohesion. Large circles of red, orange and yellow represent these problematic classes. When all these analysis results are taken into account, it is clear that the cb-1 code base has complexity, coupling and cohesion problems even for simple features, and therefore shows a low maintainability character.

%In this section, the interpretation of the results obtained from the feature-based metric comparison over the login feature of cb-1 and cb-2 are shared.

%First of all, it is seen that the cb-1 codebase uses 6 classes and interfaces for the visual part of the login feature, while cb-2 uses only 2 classes for this feature. From this point of view, the cb-2 code is better in terms of organization and understandability. On the other hand, when the metric values given in Fig. \ref{fig:login-metric-table} are examined, it is seen that the results of cb-2 are better than the results of cb-1.

%When the metric values shared in Fig. \ref{fig:login-metric-table-2} are examined, the difference between the view responsibilities of the two projects on complexity draws attention. When the values of WMC, DIT and NOC metrics used in complexity measurement are compared, it is seen that the complexity level of cb-2 for the view responsibility is lower. On the other hand, when the results of the complexity metric values of view logic related responsibilities are examined, it is observed that there is not much difference between the two code bases. As explained in previous sections, these results should be considered normal given the complexity of functionality of the classes involved in this responsibility.

%When the CBO metric related to measuring the coupling level is examined, it is seen that the cb-2 codebase gives better results. Since the SOLID and DI principles are used much more effectively in the cb-2 codebase, these results are not different from what is expected. As mentioned before, cb-1 uses the MVP design pattern. Coupling is increasing due to the bi-directional dependency between view and presentation layers in the MVP design pattern. It would not be wrong to say that this situation increases the coupling level of the cb-1. However, this situation is not the case for cb-2, which uses the MVVM design pattern. In the MVVM design pattern, only the view layer has a dependency on the presentation layer.

%When the results of the LCOM metric related to cohesion are examined, it is seen that the results are similar to the results of the complexity metrics. While the results of cb-2 are much better than cb-1 for the responsibility of view, there is not much difference between the results for the responsibility of presentation. As explained in the previous section, there is only one view model per view principle in the MVVM design pattern. Therefore, one view model might have different responsibilities, especially those that belong to the complex views. Thus this circumstance can be shown as a reason for this situation. The same is true for the MVP design pattern as well. There can only be one presenter for each view. Naturally, cb-1, which uses the MVP design pattern, seems to have low cohesion values for presentation responsibility.

%As a result, when looking at the general situation of the feature-based metric comparison, there are big improvements in the complexity and cohesion areas for the classes related to the view responsibility of cb-2 compared to the cb-1. At the same time, there is not much difference in terms of view logic/presentation responsibility. On the other hand, in the coupling, it has been determined that the cb-2 codebase is better than the cb-1, and the reasons for this situation have been mentioned in the previous sections.