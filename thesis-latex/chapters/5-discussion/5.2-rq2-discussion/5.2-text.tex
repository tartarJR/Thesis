First of all, when the results obtained from the Android developer survey are compared with the methods used by the Mooncasacade Android team, it is seen that the methods used largely overlap with the community choices. Although there are slight differences between the methods used by the team and the general Android developer choices, it can be said that these differences can be met normally.Although all the participants are Android developers, the users participating in the survey work in different companies and different domain, and it would not be wrong to say that the needs of these participants may vary according to the company and field they work in and that the methods and technologies they use are shaped according to their needs. On the other hand, the case of different user tendencies seen in the answers of the survey questions on the architectural pattern choice and the asynchronous event management libraries might be interpreted as the case company needs to re-evaluate the solutions used for these areas. Lastly, In the participants' responses to some questions, it is noteworthy that the participants choose more according to the trends of the industry, and this situation is observed especially in the answers given by relatively less experienced developers. As stated in the previous chapters, the Android platform is a rapidly developing platform. Therefore, it is worth noting that while choosing the methods and technologies used while developing Android applications should be made based on long-term stability and maintainability rather than industrial trends.

When the results of the interviews with the case company's Android team are examined, it is seen that the team consists of highly experienced Android developers, and they are aware of the importance of maintainability in software engineering and Android applications. Therefore, it would not be wrong to mention that the quality of the answers given by the team members to the questions in the interviews is high. First of all, five out of seven participants stated that maintainability is vital for the company and Android applications due to the way the company operates and the nature of Android applications. The other two participants stated that maintainability is already essential for software systems. These results support the theory claimed in the problem statement section of this study on maintainability that it is a critical non-functional requirement for software systems, Android applications and the case company. Besides, while the participants' evaluations about the methods and technologies used by the company in developing Android applications are generally positive, some constructive criticism also draws attention. The necessity of reconsidering the choice of architectural pattern and the asynchronous event management libraries, which was also mentioned in the Android developer survey interpretations above, was also emphasized by some case company members in the interviews. This situation stands out as a topic that the case company should focus on. The difficulties of using the RxJava library and its beginning to become out of date and the usage of Clean Architecture causing too much complexity for small and medium-sized projects are indicated as the reasons for this situation by the participants. In addition, the participants expressed their views that making the methods used into more standard coding conventions and arranging these conventions as if they were a familiar language among all members of the team would have a positive effect in terms of maintainability. Lastly, the views and awareness of most of the participants about choosing the libraries used in Android projects among stable and long-lasting libraries prove the effect of third party library use on the maintainability of Android applications.

Considering the quantitative evaluation results, some issues from CB-1 stand out. The first thing that catches the eye is a complex and unorganized packaging structure. Layer and feature-based packaging methods are internal in the project, which causes serious maintainability, understandability and organization problems. It is also noteworthy that some classes are large in size, which can be interpreted as lack of proper separation of concerns. The codebase appears to have complexity, coupling and cohesion problems as well. In a few classes, these problems are at a very high level, and maintainability and organization problems at different levels in the project draw attention. Especially the coupling problem stands out for this code base. Considering that there are no healthy abstraction and dependency injection application in the project, this result is not very surprising. When all these analysis results are taken into account, it is clear that the cb-1 codebase shows a low maintainability character. Nevertheless, situation the situation of cb-1 offered an opportunity for this study to evaluate maintainability. On the other hand, results of CB-2 has shown that there are visible improvements in complexity, coupling and cohesion. In addition, significantly reduced entity sizes and increased class and package numbers were noticed. Concise classes and the increase in the number of packages point to a more organized code base and a better separation of concerns, making the understandability of the codebase high. Besides, the levels of the classes in complexity, coupling are quite low, and cohesion is high. This situation can be shown as proof that the SOLID and SoC principles are applied correctly, and it can be said that there is a very positive effect on maintainability. However, a few classes with moderate complexity and cohesion issues stand out. When these classes were investigated, it was seen that they were the classes called "View Model" in the MVVM design pattern that are responsible for how and when the data will be displayed. According to the principles of the MVVM design pattern, each view should have only one view model. In this case, the view models belonging to the views with more than one responsibility also have the logic of belonging to more than one responsibility. Therefore, these classes become more complex, and the cohesion of the classes decreases due to the methods and dependencies they have for different responsibilities. As long as the principles of the MVVM design pattern are followed, it would not be appropriate to divide these responsibilities between different classes. Nevertheless, the effects of the technology and principles used in the development of cb-2 on maintainability are obvious.

When the feature-based comparison results between the two codebases are examined, it is seen that the cb-1 codebase uses 6 classes and interfaces for the visual part of the login feature, while cb-2 uses only 2 classes for this feature. From this point of view, the cb-2 code is better in terms of organization and understandability. Also, the metric values presented in Fig. \ref{fig:login-metric-table} have shown that the results of cb-2 are better than the results of cb-1. In addition, the metric values presented in Fig. \ref{fig:login-metric-table-2} has shown the difference between the view responsibilities of the two projects on complexity. When the values of WMC, DIT and NOC metrics used in complexity measurement are compared, it is seen that the complexity level of cb-2 for the view responsibility is lower. On the other hand, when the results of the complexity metric values of view logic related responsibilities are examined, it is observed that there is not much difference between the two code bases. As explained in previous sections, these results should be considered normal given the complexity of functionality of the classes involved in this responsibility. When the CBO metric related to measuring the coupling level is examined, it is seen that the cb-2 codebase gives better results. Since the SOLID and DI principles are used much more effectively in the cb-2 codebase, these results are not different from what is expected. Also, cb-1 uses the MVP design pattern. Coupling is increasing due to the bi-directional dependency between view and presentation layers in the MVP design pattern. It would not be wrong to say that this situation increases the coupling level of the cb-1. However, this situation is not the case for cb-2, which uses the MVVM design pattern. In the MVVM design pattern, only the view layer has a dependency to the presentation layer. When the results of the LCOM metric related to cohesion are examined, it is seen that the results are similar to the results of the complexity metrics. While the results of cb-2 are much better than cb-1 for the responsibility of view, there is not much difference between the results for the responsibility of presentation. As explained in the previous section, there is only one view model per view principle in the MVVM design pattern. Therefore, one view model might have different responsibilities, especially those that belong to the complex views. The same is true for the MVP design pattern as well. There can be only one presenter for each view. Naturally, cb-1, which uses the MVP design pattern, seems to have low cohesion values for presentation responsibility. Ultimately, results obtained from the qualitative and quantitative evaluations have shown that the effects of the methods and technologies used by the case company on the maintainability of Android applications are seen as positive, yet some points need improvement. The results also showed the importance of maintainability for the software systems, Android applications and particularly for the case company. 